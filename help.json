{
  "crypto": {
    "aes": {
      "description": "Encrypts or decrypts 'sym1 using the Advanced Encryption Standard (AES) in CTR mode, using 'sym2 as password.",
      "input": "'sym1 'sym2",
      "name": "aes",
      "output": "string"
    },
    "decode": {
      "description": "Decodes the Base64-encoded string 'sym.",
      "input": "'sym",
      "name": "decode",
      "output": "string"
    },
    "encode": {
      "description": "Base64-encodes 'sym.",
      "input": "'sym",
      "name": "encode",
      "output": "string"
    },
    "md4": {
      "description": "Returns the MD4 hash of 'sym.",
      "input": "'sym",
      "name": "md4",
      "output": "string"
    },
    "md5": {
      "description": "Returns the MD5 hash of 'sym.",
      "input": "'sym",
      "name": "md5",
      "output": "string"
    },
    "sha1": {
      "description": "Returns the SHA1 hash of 'sym.",
      "input": "'sym",
      "name": "sha1",
      "output": "string"
    },
    "sha224": {
      "description": "Returns the SHA224 hash of 'sym.",
      "input": "'sym",
      "name": "sha224",
      "output": "string"
    },
    "sha256": {
      "description": "Returns the SHA256 hash of 'sym.",
      "input": "'sym",
      "name": "sha256",
      "output": "string"
    },
    "sha384": {
      "description": "Returns the SHA384 hash of 'sym.",
      "input": "'sym",
      "name": "sha384",
      "output": "string"
    },
    "sha512": {
      "description": "Returns the SHA512 hash of 'sym.",
      "input": "'sym",
      "name": "sha512",
      "output": "string"
    }
  },
  "dict": {
    "ddel": {
      "description": "Removes 'sym from dict1 and returns dict1.",
      "input": "dict 'sym",
      "name": "ddel",
      "output": "dict"
    },
    "ddup": {
      "description": "Returns a copy of dict1.",
      "input": "dict1",
      "name": "ddup",
      "output": "dict2"
    },
    "dget": {
      "description": "Returns the value of key 'sym from dictionary dict.",
      "input": "dict 'sym",
      "name": "dget",
      "output": "a"
    },
    "dhas?": {
      "description": "Returns true if dictionary dict contains the key 'sym, false  otherwise.\n \n \n Example\n  \n The following program returns true:\n \n     {true :a1 \"aaa\" :a2 false :a3} 'a2 dhas?",
      "input": "dict 'sym",
      "name": "dhas?",
      "output": "bool"
    },
    "dkeys": {
      "description": "Returns a quotation containing all the keys of dictionary dict.",
      "input": "dict",
      "name": "dkeys",
      "output": "(string*)"
    },
    "dpairs": {
      "description": "Returns a quotation containing all the keys (odd items) and values (even items) of dictiionary dict.",
      "input": "dict",
      "name": "dpairs",
      "output": "(a*)"
    },
    "dpick": {
      "description": "Returns a new dictionary dict2 containing the elements of dict1 whose keys are included in quot.\n \n \n Example\n  \n The following program returns {4 :a 7 :d}:\n \n     {5 :q 4 :a 6 :c 7 :d \"d\" :a} (\"a\" \"d\") dpick",
      "input": "dict1 quot",
      "name": "dpick",
      "output": "dict2"
    },
    "dset": {
      "description": "Sets the value of the 'sym of dict1  to a, and returns the modified dictionary dict.",
      "input": "dict a 'sym",
      "name": "dset",
      "output": "dict"
    },
    "dtype": {
      "description": "Returns a string set to the type of dict (empty if the dictionary has no type).",
      "input": "dict",
      "name": "dtype",
      "output": "string"
    },
    "dvalues": {
      "description": "Returns a quotation containing all the values of dictionary dict.",
      "input": "dict",
      "name": "dvalues",
      "output": "(a*)"
    }
  },
  "dstore": {
    "dsdelete": {
      "description": "Removes an item from the datastore dict:datastore. The item is uniquely identified by 'sym, which contains the collection containing the item and the item id, separated by a forward slash (/). Puts the reference to the modified datastore back on tbe stack.",
      "input": "dict:datastore 'sym",
      "name": "dsdelete",
      "output": "dict:datastore"
    },
    "dsdelete!": {
      "description": "Same as dsdelete, but doesn't leave anything on the stack.",
      "input": "dict:datastore 'sym",
      "name": "dsdelete!",
      "output": ""
    },
    "dsget": {
      "description": "Retrieves item dict from datastore dict:datastore. dict is retrieved by specifying 'sym, which contains the collection containing the item and the item id, separated by a forward slash (/).",
      "input": "dict:datastore 'sym",
      "name": "dsget",
      "output": "dict"
    },
    "dsinit": {
      "description": "Initializes a bew datastore by creating the 'sym JSON file. Puts the datastore instance on the stack.",
      "input": "'sym",
      "name": "dsinit",
      "output": "dict:datastore"
    },
    "dsinit!": {
      "description": "Same as dsinit, but doesn't leave anything on the stack.",
      "input": "'sym dict",
      "name": "dsinit!",
      "output": ""
    },
    "dspost": {
      "description": "Adds the dictionary dict to the datastore dict:datastore inside collection 'sym, generating and adding a unique **id** field to dict. If the collection 'sym does not exist it is created. Puts the reference to the modified datastore back on tbe stack.",
      "input": "dict:datastore 'sym dict",
      "name": "dspost",
      "output": "dict:datastore"
    },
    "dspost!": {
      "description": "Same as dspost, but doesn't leave anything on the stack.",
      "input": "dict:datastore 'sym dict",
      "name": "dspost!",
      "output": ""
    },
    "dsput": {
      "description": "Adds the dictionary dict to the datastore dict:datastore. 'sym contains the collection where dict will be placed and the id of dict, separated by a forward slash (/). If the collection 'sym does not exist it is created. Puts the reference to the modified datastore back on tbe stack.",
      "input": "dict:datastore 'sym dict",
      "name": "dsput",
      "output": "dict:datastore"
    },
    "dsput!": {
      "description": "Same as dsput, but doesn't leave anything on the stack.",
      "input": "dict:datastore 'sym",
      "name": "dsput!",
      "output": ""
    },
    "dsquery": {
      "description": "Retrieves a quotation of dictionaries from the collection 'sym of datastore dict:datastore obtained by applying quot as a filter to each item of the collection, picking only the elements that match the filter.\n\n \n Example\n\n Assuming that **ds** is a datastore, the following program retrieves all elements of teh collection **posts** whose author field is set to \"h3rald\":\n\n      ds \"posts\" (/author \"h3rald\" ==) dsquery",
      "input": "dict:datastore 'sym quot",
      "name": "dsquery",
      "output": "(dict*)"
    },
    "dsread": {
      "description": "Reads the previously-created datastore from the file 'sym and puts the resulting datastore instance on the stack.",
      "input": "'sym",
      "name": "dsread",
      "output": "dict:datastore"
    },
    "dswrite": {
      "description": "Writes the contents of the datastore dict:datastore to the filesystem.",
      "input": "dict:datastore",
      "name": "dswrite",
      "output": "dict:datastore"
    },
    "dswrite!": {
      "description": "Same as dswrite, but doesn't leave anything on the stack.",
      "input": "dict:datastore",
      "name": "dswrite!",
      "output": ""
    }
  },
  "fs": {
    "atime": {
      "description": "Returns a timestamp corresponding to the time that file/directory 'sym was last accessed.",
      "input": "'sym",
      "name": "atime",
      "output": "float"
    },
    "ctime": {
      "description": "Returns a timestamp corresponding to the time that file/directory 'sym was created.",
      "input": "'sym",
      "name": "ctime",
      "output": "float"
    },
    "fperms": {
      "description": "Returns the Unix permissions (expressed as a three-digit number) of file/directory 'sym.",
      "input": "'sym",
      "name": "fperms",
      "output": "int"
    },
    "fsize": {
      "description": "Returns the size in bytes of file/directory 'sym.",
      "input": "'sym",
      "name": "fsize",
      "output": "int"
    },
    "fstats": {
      "description": "Returns a dictionary dict containing information on file/directory 'sym.\n \n Example\n \n Assuming that min is a file, the following:\n \n \"min\" fstats\n \n produces:\n \n      {\n        \"min\" :name\n        16777220 :device\n        50112479 :file\n        \"file\" :type\n        617068 :size\n        755 :permissions\n        1 :nlinks\n        1496583112.0 :ctime\n        1496584370.0 :atime\n        1496583112.0 :mtime\n      }",
      "input": "'sym",
      "name": "fstats",
      "output": "dict"
    },
    "ftype": {
      "description": "Returns the type of file/directory 'sym (\"file\" or \"dir\").",
      "input": "'sym",
      "name": "ftype",
      "output": "string"
    },
    "hidden?": {
      "description": "Returns true if file/directory 'sym is hidden, false  otherwise.",
      "input": "'sym",
      "name": "hidden?",
      "output": "bool"
    },
    "mtime": {
      "description": "Returns a timestamp corresponding to the time that file/directory 'sym was last modified.",
      "input": "'sym",
      "name": "mtime",
      "output": "float"
    }
  },
  "http": {
    "download": {
      "description": "Downloads the contents of URL string1 to the local file string2.",
      "input": "string1 string2",
      "name": "download",
      "output": ""
    },
    "get-content": {
      "description": "Retrieves the contents of URL string1 as string2.",
      "input": "string1",
      "name": "get-content",
      "output": "string2"
    },
    "request": {
      "description": "Performs an HTTP request.\n \n \n Example\n \n The following code constructs a request dictionary and passes it to the **request** operator to perform an HTTP GET request to <http://httpbin.org/ip:\n \n     {}\n       \"GET\" url\n     request",
      "input": "request",
      "name": "request",
      "output": "response"
    },
    "start-server": {
      "description": "Starts an HTTP server based on the configuration provided in dict.\n \n dict is a dictionary containing the following keys:\n \n address\n : The address to bind the server to (default: **127.0.0.1**).\n port\n : The port to bind the server to.\n handler\n : A quotation with the following signature, used to handle all incoming requests: [request &rArr; response](class:kwd)\n \n \n Example\n \n The following program starts a very simple HTTP server that can display the current timestamp or date and time in ISO 8601 format:\n \n     ; Define the request handler\n     (\n       ; Assume there is a request on the stack, take it off and give it the name req\n       :req\n       ; Let's see what we got (print req to standard out)\n       \"THE REQUEST:\" puts! req puts!\n       ; The request is a dictionary, we retrieve the value for the key url, and give it the name url\n       req /url :url\n       \"THE URL is '$1'.\" url quote ))\n       ) case\n       :body\n       ; Prepare the response\n       {} body handler\n     5555 %port\n     \n     ; Start server\n     \"Server started on port 5555.\" puts!\n     \"Press Ctrl+C to stop.\" puts!\n     start-server",
      "input": "dict",
      "name": "start-server",
      "output": ""
    },
    "stop-server": {
      "description": "Stops the currently-running HTTP server. This operator should be used within an HTTP server handler quotation.",
      "input": "",
      "name": "stop-server",
      "output": ""
    }
  },
  "io": {
    "ask": {
      "description": "Prints string1 (prompt), reads a line from STDIN and places it on top of the stack as a string.",
      "input": "string1",
      "name": "ask",
      "output": "string2"
    },
    "choose": {
      "description": "Prints string2, then prints all string1 included in the quotation prepended with a number, and waits from valid input from the user.\n \n If the user enters a number that matches one of the choices, then the corresponding quotation quot1 is executed, otherwise the choice menu is displayed again until a valid choice is made.",
      "input": "((string1 quot1)+) string2",
      "name": "choose",
      "output": "a*"
    },
    "clear": {
      "description": "Clears the screen.",
      "input": "",
      "name": "clear",
      "output": ""
    },
    "column-print": {
      "description": "Prints all elements of quot to STDOUT, in int columns.",
      "input": "quot int",
      "name": "column-print",
      "output": "a"
    },
    "confirm": {
      "description": "Prints string (prompt) appending \" [yes/no]: \", reads a line from STDIN and:\n \n  * if it matches /^y(es)?$/i, puts true on the stack.\n  * if it matches /^no?$/i, puts false  on the stack. \n  * Otherwise, it prints Invalid answer. Please enter 'yes' or 'no':  and waits for a new answer.",
      "input": "string",
      "name": "confirm",
      "output": "bool"
    },
    "debug": {
      "description": "Prints a and a new line to STDOUT, if logging level is set to [debug](class:kwd) or lower.",
      "input": "a",
      "name": "debug",
      "output": "a"
    },
    "debug!": {
      "description": "Prints a (removing it from the stack) and a new line to STDOUT, if logging level is set to [debug](class:kwd) or lower.",
      "input": "a",
      "name": "debug!",
      "output": ""
    },
    "error": {
      "description": "Prints a and a new line to STDERR, if logging level is set to [error](class:kwd) or lower.",
      "input": "a",
      "name": "error",
      "output": "a"
    },
    "error!": {
      "description": "Prints a (removing it from the stack) and a new line to STDERR, if logging level is set to [error](class:kwd) or lower.",
      "input": "a",
      "name": "error!",
      "output": ""
    },
    "fappend": {
      "description": "Appends string1 to the end of file string2.",
      "input": "string1 string2",
      "name": "fappend",
      "output": ""
    },
    "fatal": {
      "description": "Prints a and a new line to STDERR, and exists the program with error code 100.",
      "input": "a",
      "name": "fatal",
      "output": "a"
    },
    "fread": {
      "description": "Reads the file string and puts its contents on the top of the stack as a string.",
      "input": "string",
      "name": "fread",
      "output": "string"
    },
    "fwrite": {
      "description": "Writes string1 to the file string2, erasing all its contents first.",
      "input": "string1 string2",
      "name": "fwrite",
      "output": ""
    },
    "getchr": {
      "description": "Reads single character from STDIN without waiting for ENTER key and places its ASCII code on top of the stack.",
      "input": "",
      "name": "getchr",
      "output": "int"
    },
    "info": {
      "description": "Prints a and a new line to STDOUT, if logging level is set to [info](class:kwd) or lower.",
      "input": "a",
      "name": "info",
      "output": "a"
    },
    "info!": {
      "description": "Prints a (removing it from the stack) and a new line to STDOUT, if logging level is set to [info](class:kwd) or lower.",
      "input": "a",
      "name": "info!",
      "output": ""
    },
    "mapkey": {
      "description": "Maps the named key/key combination 'sym to the quotation quot, so that quot is executed when key 'sym is pressed. \n\n \n Notes\n\n * At present, only the key names and sequences defined in the [nimline](https://h3rald.com/nimline/nimline.html) library are supported.\n * The quotation will be executed by a copy of the min interpreter created when the mapping was defined. In other words, quotations executed by key bindings will not affect the current stack.\n \n \n Example\n \n The following program:\n \n     (clear) 'ctrl+l keymap\n \n causes the CTRL+L key to clear the screen.",
      "input": "quot 'sym",
      "name": "mapkey",
      "output": ""
    },
    "newline": {
      "description": "Prints a new line to STDOUT.",
      "input": "",
      "name": "newline",
      "output": ""
    },
    "notice": {
      "description": "Prints a and a new line to STDOUT, if logging level is set to [notice](class:kwd) (default) or lower.",
      "input": "a",
      "name": "notice",
      "output": "a"
    },
    "notice!": {
      "description": "Prints a (removing it from the stack) and a new line to STDOUT, if logging level is set to [notice](class:kwd) (default) or lower.",
      "input": "a",
      "name": "notice!",
      "output": ""
    },
    "password": {
      "description": "Reads a line from STDIN displaying \\* for each typed character, and places it on top of the stack as a string.",
      "input": "",
      "name": "password",
      "output": "string"
    },
    "print": {
      "description": "Prints a to STDOUT.",
      "input": "a",
      "name": "print",
      "output": "a"
    },
    "print!": {
      "description": "Prints a to STDOUT and removes a from the stack.",
      "input": "a",
      "name": "print!",
      "output": ""
    },
    "putchr": {
      "description": "Prints string to STDOUT without printing a new line (string must contain only one character).",
      "input": "string",
      "name": "putchr",
      "output": "a"
    },
    "type": {
      "description": "Puts the data type of a on the stack. In cased of typed dictionaries, the type name is prefixed by dict:, e.g. dict:module, dict:socket, etc.",
      "input": "a",
      "name": "type",
      "output": "string"
    },
    "unmapkey": {
      "description": "Unmaps a previously-mapped key or key-combination 'sym, restoring the default mapping if available.\n\n \n Notes\n\n * At present, only the key names and sequences defined in the [nimline](https://h3rald.com/nimline/nimline.html) library are supported.\n * At present, all the default mappings of min are those provided by the [nimline](https://h3rald.com/nimline/nimline.html) library.",
      "input": "'sym",
      "name": "unmapkey",
      "output": ""
    },
    "warning": {
      "description": "Prints a and a new line to STDERR, if logging level is set to [warning](class:kwd) or lower.",
      "input": "a",
      "name": "warning",
      "output": "a"
    },
    "warning!": {
      "description": "Prints a (removing it from the stack) and a new line to STDERR, if logging level is set to [warning](class:kwd) or lower.",
      "input": "a",
      "name": "warning!",
      "output": ""
    }
  },
  "lang": {
    "==": {
      "description": "Symbol used to separate input and output calues in operator signatures.",
      "input": "",
      "name": "==",
      "output": ""
    },
    "ROOT": {
      "description": "Returns a module holding a reference to the [ROOT](class:kwd) scope.\n\n \n Tip\n \n This symbol is very useful in conjunction with the **with** operator.",
      "input": "",
      "name": "ROOT",
      "output": "dict"
    },
    "args": {
      "description": "Returns a list of all arguments passed to the current program.",
      "input": "",
      "name": "args",
      "output": "quot"
    },
    "bind": {
      "description": "Binds the specified value (auto-quoted) to an existing symbol 'sym.",
      "input": "a 'sym",
      "name": "bind",
      "output": ""
    },
    "bool": {
      "description": "Converts a to a boolean value based on the following rules:\n \n  * If a is a boolean value, no conversion is performed.\n  * If a is null, it is converted to false .\n  * If a is a numeric value, zero is converted to false , otherwise it is converted to true.\n  * If a is a quotation or a dictionary, the empty quotation or dictionary is converted to false , otherwise it is converted to true.\n  * If a is a string, the empty string, and \"false\" are converted to false , otherwise it is converted to true.",
      "input": "a",
      "name": "bool",
      "output": "bool"
    },
    "call": {
      "description": "Calls operator 'sym defined in dictionary dict.",
      "input": "dict 'sym",
      "name": "call",
      "output": "a*"
    },
    "case": {
      "description": "This operator takes a quotation containing _n_ different conditional branches. \n \n Each branch must be a quotation containing two quotations, and it is processed as follows:\n \n   * if quot1 evaluates to true, then the quot2 is executed.\n   * if quot1 evaluates to false , then the following branch is processed (if any).\n \n \n Example\n \n The following program prints \"Smaller than 3\":\n \n     2 (\n        (( 3) (\"Greater than 3\" put!))\n        ((< 3) (\"Smaller than 3\" put!))\n        ((true) (\"Exactly 3\" put!))\n     ) case",
      "input": "((quot1 quot2)*)",
      "name": "case",
      "output": "a*"
    },
    "compiled?": {
      "description": "Returns true if the current program has been compiled.",
      "input": "",
      "name": "compiled?",
      "output": "bool"
    },
    "define": {
      "description": "Defines a new symbol 'sym, containing the specified value (auto-quoted if not already a quotation).",
      "input": "a 'sym",
      "name": "define",
      "output": ""
    },
    "define-sigil": {
      "description": "Defines a new sigil 'sym, containing the specified value (auto-quoted if not already a quotation).",
      "input": "a 'sym",
      "name": "define-sigil",
      "output": ""
    },
    "defined-sigil?": {
      "description": "Returns true if the symbol 'sym is defined, false  otherwise.",
      "input": "'sym",
      "name": "defined-sigil?",
      "output": "bool"
    },
    "defined?": {
      "description": "Returns true if the symbol 'sym is defined, false  otherwise.",
      "input": "'sym",
      "name": "defined?",
      "output": "bool"
    },
    "delete": {
      "description": "Deletes the specified symbol 'sym.",
      "input": "'sym",
      "name": "delete",
      "output": ""
    },
    "delete-sigil": {
      "description": "Deletes the specified user-defined sigil 'sym.",
      "input": "'sym",
      "name": "delete-sigil",
      "output": ""
    },
    "dequote": {
      "description": "Pushes the contents of quotation quot on the stack.\n\n Each element is pushed on the stack one by one. If any error occurs, quot is restored on the stack.",
      "input": "quot",
      "name": "dequote",
      "output": "a*"
    },
    "eval": {
      "description": "Parses and interprets string.",
      "input": "string",
      "name": "eval",
      "output": "a*"
    },
    "exit": {
      "description": "Exits the program or shell with int as return code.",
      "input": "int",
      "name": "exit",
      "output": ""
    },
    "expect": {
      "description": "Validates the first _n_ elements of the stack against the type descriptions specified in quot1 (_n_ is quot1's length) and if all the elements are valid returns them wrapped in quot2 (in reverse order). \n\n \n Tips\n \n * You can specify a typed dictionary by prepending the type name with dict:. Example: dict:socket\n * You can specify two or more matching types by separating the type names with a pipe: string|quot\n\n \n Example\n \n Assuming that the following elements are on the stack (from top to bottom): \n \n 1 \"test\" 3.4\n \n the following program evaluates to true:\n \n (int string num) expect (3.4 \"test\" 1) ==",
      "input": "quot1",
      "name": "expect",
      "output": "quot2"
    },
    "expect-empty-stack": {
      "description": "Raises an error if the stack is not empty.",
      "input": "",
      "name": "expect-empty-stack",
      "output": ""
    },
    "float": {
      "description": "Converts a to an integer value based on the following rules:\n \n   * If a is true, it is converted to 1.0.\n   * If a is false , it is converted to 0.0.\n   * If a is null, it is converted to 0.0\n.  * If a is a integer, it is converted to float value.\n   * If a is a float, no conversion is performed.\n   * If a is a string, it is parsed as a float value.",
      "input": "a",
      "name": "float",
      "output": "float"
    },
    "foreach": {
      "description": "Applies the quotation quot2 to each element of quot1.",
      "input": "quot1 quot2",
      "name": "foreach",
      "output": "a*"
    },
    "format-error": {
      "description": "Formats the error dict:error as a string. \n \n Example\n \n The following: \n \n {\"MyError\" :error \"This is a test error\" :message} 'error set-type format-error\n \n produces: \"This is a test error\"",
      "input": "dict:error",
      "name": "format-error",
      "output": "string"
    },
    "from-json": {
      "description": "Converts a JSON string into min data.",
      "input": "string",
      "name": "from-json",
      "output": "a"
    },
    "from-yaml": {
      "description": "Converts a YAML string into min data.\n \n Note\n \n At present, only YAML objects containing string values are supported.",
      "input": "string",
      "name": "from-yaml",
      "output": "a"
    },
    "gets": {
      "description": "Reads a line from STDIN and places it on top of the stack as a string.",
      "input": "",
      "name": "gets",
      "output": "string"
    },
    "help": {
      "description": "Prints the help text for 'sym, if available.",
      "input": "'sym",
      "name": "help",
      "output": ""
    },
    "if": {
      "description": "If quot1 evaluates to true then evaluates quot2, otherwise evaluates quot3.",
      "input": "quot1 quot2 quot3",
      "name": "if",
      "output": "a*"
    },
    "import": {
      "description": "Imports the a previously-loaded module 'sym, defining all its symbols in the current scope.",
      "input": "'sym",
      "name": "import",
      "output": ""
    },
    "infix-dequote": {
      "description": "Dequotes quot using infix notation. \n \n Note that no special operator preference is defined, symbols precedence is always left-to-right. However, you can use parentheses (quotes) to evaluate expressions before others.\n \n \n Example\n \n The following program leaves 17 on the stack:\n\n      (2 + (3 * 5)) infix-dequote\n\n while this program leaves 25 on the stack:\n \n      (2 + 3 * 5) infix-dequote",
      "input": "quot",
      "name": "infix-dequote",
      "output": "a"
    },
    "int": {
      "description": "Converts a to an integer value based on the following rules:\n \n   * If a is true, it is converted to 1.\n   * If a is false , it is converted to 0.\n   * If a is null, it is converted to 0.\n   * If a is an integer, no conversion is performed.\n   * If a is a float, it is converted to an integer value by truncating its decimal part.\n   * If a is a string, it is parsed as an integer value.",
      "input": "a",
      "name": "int",
      "output": "int"
    },
    "invoke": {
      "description": "Assming that 'sym is a formatted like *dictionary*/*symbol*, calls *symbol* defined in *dictionary* (note that this also works for nested dictionaries. \n \n \n Example\n \n The following program leaves 100 on the stack:\n \n     {{100 :b} :a} :test *test/a/b",
      "input": "'sym",
      "name": "invoke",
      "output": "a*"
    },
    "line-info": {
      "description": "Returns a dictionary dict containing a **filename**, **line**, and **column** properties identifying the filename, line and column of the current symbol.",
      "input": "",
      "name": "line-info",
      "output": "dict"
    },
    "linrec": {
      "description": "Implements linear recursions as follows:\n \n   1. Evaluates quot1.\n     * If quot1 evaluates to true, then it evaluates quot2.\n     * Otherwises it executes quot3 and recurses using the same four quotations.\n   2. Finally, it executes quot4.\n \n \n Example\n \n The following program leaves 120 on the stack, the factorial of 5:\n \n    5 (dup 0 ==) 'succ (dup pred) '* linrec",
      "input": "quot1 quot2 quot3 quot4",
      "name": "linrec",
      "output": "a*"
    },
    "lite?": {
      "description": "Returns true if min was built in _lite_ mode.",
      "input": "",
      "name": "lite?",
      "output": "bool"
    },
    "load": {
      "description": "Parses and interprets the specified min file 'sym, adding [.min](class:ext) if not specified.",
      "input": "'sym",
      "name": "load",
      "output": "a*"
    },
    "load-symbol": {
      "description": "Loads the contents of symbol 'sym from the [.min\\_symbols](class:file) file.",
      "input": "'sym",
      "name": "load-symbol",
      "output": "a*"
    },
    "loglevel": {
      "description": "Sets the current logging level to 'sym. 'sym must be one of the following strings or quoted symbols:\n \n   * debug\n   * info\n   * notice\n   * warn\n   * error\n   * fatal\n \n \n Note\n \n The default logging level is _notice_.",
      "input": "'sym",
      "name": "loglevel",
      "output": ""
    },
    "loglevel?": {
      "description": "Returns the current log level (debug, info, notive, warn, error or fatal).",
      "input": "",
      "name": "loglevel?",
      "output": "string"
    },
    "module": {
      "description": "Creates a new module 'sym based on dictionary dict.",
      "input": "dict 'sym",
      "name": "module",
      "output": ""
    },
    "operator": {
      "description": "Provides a way to define a new operator (symbol or sigil) on the current scope performing additional checks (compared to define and define-sigil), and automatically mapping inputs and outputs.\n \n quot is a quotation containing:\n \n * A symbol identifying the type of operator to define (symbol or sigil).\n * A symbol identifying the name of the operator.\n * A quotation defining the signature of the operatorm containing input and output values identified by their type and a capturing symbol, separated by the == symbol.\n * A quotation identifying the body of the operator.\n\n The main additional features offered by this way of defining operators are the following:\n\n * Both input and output values are checked against a type (like when using the expect operator *and* automatically captured in a symbol that can be referenced in the operator body quotation.\n * The full signature of the operator is declared, making the resulting code easier to understand at quick glance.\n * An exception is automatically raised if the operator body pollutes the stack by adding or removing elementa from the stack (besides adding the declared output values).\n * It is possible to use the return symbol within the body quotation to immediately stop the evaluation of the body quotation and automatically push the output values on the stack.\n \n \n Example\n \n The following program defines a pow operator that calculates the power of a number providing its base and exponent, and handling some NaN results using the return symbol:\n\n      (\n        symbol pow\n        (num :base int :exp == num :result)\n        ( \n          (base 0 == exp 0 == and)\n            (nan @result return)\n          when\n          (base 1 == exp inf == and)\n            (nan @result return)\n          when\n          (base inf == exp 0 == and)\n            (nan @result return)\n          when\n          exp 1 - :n\n          base  (dup) n times (*) n times @result\n        )\n      ) ::",
      "input": "quot",
      "name": "operator",
      "output": "a*"
    },
    "opts": {
      "description": "Returns a dictionary of all options passed to the current program, with their respective values.",
      "input": "",
      "name": "opts",
      "output": "dict"
    },
    "parse": {
      "description": "Parses string and returns a quoted program quot.",
      "input": "string",
      "name": "parse",
      "output": "quot"
    },
    "prefix-dequote": {
      "description": "Dequotes quot using prefix notation (essentially it reverses quot and dequotes it).\n \n \n Example\n \n The following program leaves 4 on the stack:\n\n     (* 8 4) prefix-dequote",
      "input": "quot",
      "name": "prefix-dequote",
      "output": "a"
    },
    "prompt": {
      "description": "This symbol is used to configure the prompt of the min shell. By default, it is set to the following quotation:\n \n     (\"[$1]$$ \" (.) = %)\n \n Unlike other predefined symbols, this symbol is _unsealed_, which means it can be modified.",
      "input": "",
      "name": "prompt",
      "output": "string"
    },
    "publish": {
      "description": "Publishes symbol 'sym to the scope of dict.\n \n \n Example\n \n Publish symbol [my-local-symbol](class:kwd) to [ROOT](class:kwd) scope:\n 'my-local-symbol ROOT publish",
      "input": "'sym dict",
      "name": "publish",
      "output": ""
    },
    "puts": {
      "description": "Prints a and a new line to STDOUT.",
      "input": "a",
      "name": "puts",
      "output": "a"
    },
    "puts!": {
      "description": "Prints a and a new line to STDOUT, removing a from the stack.",
      "input": "a",
      "name": "puts!",
      "output": ""
    },
    "quit": {
      "description": "Exits the program or shell with 0 as return code.",
      "input": "",
      "name": "quit",
      "output": ""
    },
    "quote": {
      "description": "Wraps a in a quotation.",
      "input": "a",
      "name": "quote",
      "output": "(a)"
    },
    "quote-bind": {
      "description": "Quotes a and binds the quotation to the existing symbol 'sym.",
      "input": "a 'sym",
      "name": "quote-bind",
      "output": ""
    },
    "quote-define": {
      "description": "Quotes a and assigns the quotation to the symbol 'sym, creating it if not already defined.",
      "input": "a 'sym",
      "name": "quote-define",
      "output": ""
    },
    "raise": {
      "description": "Raises the error specified via the dictionary dict:error.",
      "input": "dict:error",
      "name": "raise",
      "output": ""
    },
    "raw-args": {
      "description": "Returns a list of all arguments and (non-parsed) options passed to the current program.",
      "input": "",
      "name": "raw-args",
      "output": "quot"
    },
    "remove-symbol": {
      "description": "Removes the symbol 'sym from the [.min\\_symbols](class:file) file.",
      "input": "'sym",
      "name": "remove-symbol",
      "output": ""
    },
    "require": {
      "description": "Parses and interprets (in a separater interpreter) the specified min file 'sym, adding [.min](class:ext) if not specified, and returns a module dictionary dict containing all the symbols defined in 'sym.",
      "input": "'sym",
      "name": "require",
      "output": "dict"
    },
    "return": {
      "description": "If used within the body quotation of an operator definition, causes the interpreter to stop pushing further body elements on the stack and start pushing tbe operator output values on the stack. \n\nIf used outside of the body quotation of an operator definition, it raises an exception.",
      "input": "",
      "name": "return",
      "output": ""
    },
    "save-symbol": {
      "description": "Saves the contents of symbol 'sym to the [.min\\_symbols](class:file) file.",
      "input": "'sym",
      "name": "save-symbol",
      "output": ""
    },
    "saved-symbols": {
      "description": "Returns a quotation containing all symbols saved in the [.min\\_symbols](class:file) file.",
      "input": "",
      "name": "saved-symbols",
      "output": "(string*)"
    },
    "scope": {
      "description": "Returns a dictionary dict holding a reference to the current scope.\n  \n This can be useful to save a reference to a given execution scope to access later on.\n\n \n Example\n \n The following program leaves {(2) :two ;module} on the stack:\n \n     {} :myscope (2 :two scope @myscope) -",
      "input": "",
      "name": "scope",
      "output": "dict"
    },
    "scope-sigils": {
      "description": "Returns a list of all sigils defined in dictionary dict.",
      "input": "dict",
      "name": "scope-sigils",
      "output": "(string*)"
    },
    "scope-symbols": {
      "description": "Returns a list of all symbols defined in dictionary dict.",
      "input": "dict",
      "name": "scope-symbols",
      "output": "(string*)"
    },
    "seal": {
      "description": "Seals symbol 'sym, so that it cannot be re-assigned.",
      "input": "'sym",
      "name": "seal",
      "output": ""
    },
    "seal-sigil": {
      "description": "Seals the user-defined sigil 'sym, so that it cannot be re-defined.",
      "input": "'sym",
      "name": "seal-sigil",
      "output": ""
    },
    "sealed-sigil?": {
      "description": "Returns true if the sigil 'sym is sealed, false  otherwise.",
      "input": "'sym",
      "name": "sealed-sigil?",
      "output": "bool"
    },
    "sealed?": {
      "description": "Returns true if the symbol 'sym is sealed, false  otherwise.",
      "input": "'sym",
      "name": "sealed?",
      "output": "bool"
    },
    "set-type": {
      "description": "Sets the type for dictionary dict to 'sym.",
      "input": "dict 'sym",
      "name": "set-type",
      "output": "dict"
    },
    "sigils": {
      "description": "Returns a list of all sigils defined in the [ROOT](class:kwd) scope.",
      "input": "",
      "name": "sigils",
      "output": "(string*)"
    },
    "source": {
      "description": "Display the source code of symbol 'sym (if it has been implemented a min quotation).",
      "input": "'sym",
      "name": "source",
      "output": "quot"
    },
    "string": {
      "description": "Converts a to its string representation.",
      "input": "a",
      "name": "string",
      "output": "string"
    },
    "symbols": {
      "description": "Returns a list of all symbols defined in the [ROOT](class:kwd) scope.",
      "input": "",
      "name": "symbols",
      "output": "(string*)"
    },
    "tap": {
      "description": "Performs the following operations:\n \n 1. Removes a from the stack.\n 2. For each quotation defined in quot (which is a quotation of quotations each requiring one argument and returning one argument):\n    1. Pushes a back to the stack.\n    2. Dequotes the quotation and saves the result as a.\n 3. Push the resulting a back on the stack.\n \n \n Example\n \n The following program:\n \n     {1 :a 2 :b 3 :c} (\n       (dup /a  succ succ b)\n     ) tap\n \n Returns {3 :a 3 :b 3 :c}.",
      "input": "a quot",
      "name": "tap",
      "output": "a"
    },
    "tap!": {
      "description": "Performs the following operations:\n \n 1. Removes a from the stack.\n 2. For each quotation defined in quot (which is a quotation of quotations each requiring one argument and returning one argument):\n    1. Pushes a back to the stack.\n    2. Dequotes the quotation and saves the result as a.\n \n \n Example\n \n The following program:\n \n     \"\" :s1\n     \"test\" (\n       (' \"1\" swap append \"\" join)\n       (' \"2\" swap append \"\" join)\n       (' \"3\" swap append \"\" join @s1 s1)\n     ) tap!\n \n Sets s1 to \"test123\".",
      "input": "a quot",
      "name": "tap!",
      "output": "a"
    },
    "times": {
      "description": "Applies the quotation quot int times.",
      "input": "quot int",
      "name": "times",
      "output": "a*"
    },
    "to-json": {
      "description": "Converts a into a JSON string.",
      "input": "a",
      "name": "to-json",
      "output": "string"
    },
    "to-yaml": {
      "description": "Converts a into a YAML string.\n\n \n Note\n \n At present, only min dictionaries containing string values are supported.",
      "input": "a",
      "name": "to-yaml",
      "output": "string"
    },
    "try": {
      "description": "Evaluates a quotation as a try/catch/finally block. \n \n The must contain the following elements:\n \n 1. A quotation quot1 containing the code to be evaluated (_try_ block).\n 1. _(optional)_ A quotation quot2 containing the code to execute in case of error (_catch_ block).\n 1. _(optional)_ A quotation quot3 containing the code to execute after the code has been evaluated, whether an error occurred or not (_finally_ block).\n \n \n Example\n \n The following program executed on an empty stack prints the message \"Insufficient items on the stack\" and pushes 0 on the stack:\n \n       (\n         (pop)\n         (format-error puts)\n         (0)\n       ) try",
      "input": "(quot1 quot2? quot3?)",
      "name": "try",
      "output": "a*"
    },
    "typeclass": {
      "description": "Defines a new type class 'sym set to quotation quot, which can be used in operator signatures.\n \n \n Example\n \n Consider the following type class which defines a natural number: \n\n      (:n ((n integer?) (n 0 )) &&) 'natural typeclass\n \n It can now be used in operator signatures, like this:\n \n      (\n        symbol natural-sum\n        (natural :n natural :m == natural :result)\n        (n m + @result)\n      ) ::",
      "input": "quot 'sym",
      "name": "typeclass",
      "output": ""
    },
    "unless": {
      "description": "If 1 evaluates to false  then evaluates 2.",
      "input": "quot1 quot2",
      "name": "unless",
      "output": "a*"
    },
    "unseal": {
      "description": "Unseals the user-defined symbol 'sym, so that it can be re-assigned.",
      "input": "'sym",
      "name": "unseal",
      "output": ""
    },
    "unseal-sigil": {
      "description": "Unseals sigil 'sym, so that it can be re-defined (system sigils cannot be unsealed).",
      "input": "'sym",
      "name": "unseal-sigil",
      "output": ""
    },
    "version": {
      "description": "Returns the current min version number.",
      "input": "",
      "name": "version",
      "output": "string"
    },
    "when": {
      "description": "If quot1 evaluates to true then evaluates quot2.",
      "input": "quot1 quot2",
      "name": "when",
      "output": "a*"
    },
    "while": {
      "description": "Executes quot2 while quot1 evaluates to true.\n \n \n Example\n \n The following program prints all natural numbers from 0 to 10:\n \n     0 :count \n     (count 10 <=) \n     (count puts succ @count) while",
      "input": "quot1 quot2",
      "name": "while",
      "output": "a*"
    },
    "with": {
      "description": "Pushes each item of quot1 on the stack using the scope of quot2 as scope. \n\n \n Example\n \n This operator is useful to define symbols on the [ROOT](class:kwd) scope or another scope. For example min's prelude includes the following code used to import certain modules only if min was not compiled in lite mode:\n \n     'lite? (\n      (\n       'crypto    import\n       'math      import\n       'net       import\n       'http      import\n      ) ROOT with\n     ) unless",
      "input": "quot1 quot2",
      "name": "with",
      "output": "a*"
    }
  },
  "logic": {
    "!=": {
      "description": "Returns true if a1 is not equal to a2, false  otherwise.",
      "input": "a1 a2",
      "name": "!=",
      "output": "bool"
    },
    "&gt;": {
      "description": "Returns true if a1 is greater than a2, false  otherwise. \n \n Note\n \n Only comparisons among two numbers or two strings are supported.",
      "input": "a1 a2",
      "name": "&gt;",
      "output": "bool"
    },
    "&gt;=": {
      "description": "Returns true if a1 is greater than or equal to a2, false  otherwise.\n \n Note\n \n Only comparisons among two numbers or two strings are supported.",
      "input": "a1 a2",
      "name": "&gt;=",
      "output": "bool"
    },
    "&lt;": {
      "description": "Returns true if a1 is smaller than a2, false  otherwise. \n \n Note\n \n Only comparisons among two numbers or two strings are supported.",
      "input": "a1 a2",
      "name": "&lt;",
      "output": "bool"
    },
    "&lt;=": {
      "description": "Returns true if a1 is smaller than or equal to a2, false  otherwise.\n \n Note\n \n Only comparisons among two numbers or two strings are supported.",
      "input": "a1 a2",
      "name": "&lt;=",
      "output": "bool"
    },
    "==": {
      "description": "Returns true if a1 is equal to a2, false  otherwise.",
      "input": "a1 a2",
      "name": "==",
      "output": "bool"
    },
    "and": {
      "description": "Returns true if bool1 is equal to bool2, false  otherwise.",
      "input": "bool1 bool2",
      "name": "and",
      "output": "bool3"
    },
    "boolean?": {
      "description": "Returns true if a is a boolean, false  otherwise.",
      "input": "a",
      "name": "boolean?",
      "output": "bool"
    },
    "dictionary?": {
      "description": "Returns true if a is a dictionary, false  otherwise.",
      "input": "a",
      "name": "dictionary?",
      "output": "bool"
    },
    "expect-all": {
      "description": "Assuming that quot is a quotation of quotations each evaluating to a boolean value, it pushes true on the stack if they all evaluate to true, false  otherwise.",
      "input": "quot",
      "name": "expect-all",
      "output": "bool"
    },
    "expect-any": {
      "description": "Assuming that quot is a quotation of quotations each evaluating to a boolean value, it pushes true on the stack if any evaluates to true, false  otherwise.",
      "input": "quot",
      "name": "expect-any",
      "output": "bool"
    },
    "float?": {
      "description": "Returns true if a is a float, false  otherwise.",
      "input": "a",
      "name": "float?",
      "output": "bool"
    },
    "integer?": {
      "description": "Returns true if a is an integer, false  otherwise.",
      "input": "a",
      "name": "integer?",
      "output": "bool"
    },
    "not": {
      "description": "Negates bool1.",
      "input": "bool1",
      "name": "not",
      "output": "bool2"
    },
    "null?": {
      "description": "Returns true if a is null, false  otherwise.",
      "input": "a",
      "name": "null?",
      "output": "bool"
    },
    "number?": {
      "description": "Returns true if a is a number, false  otherwise.",
      "input": "a",
      "name": "number?",
      "output": "bool"
    },
    "or": {
      "description": "Returns true if bool1 or bool2 is true, false  otherwise.",
      "input": "bool1 bool2",
      "name": "or",
      "output": "bool3"
    },
    "quotation?": {
      "description": "Returns true if a is a quotation, false  otherwise.",
      "input": "a",
      "name": "quotation?",
      "output": "bool"
    },
    "string?": {
      "description": "Returns true if a is a string, false  otherwise.",
      "input": "a",
      "name": "string?",
      "output": "bool"
    },
    "stringlike?": {
      "description": "Returns true if a is a string or a quoted symbol, false  otherwise.",
      "input": "a",
      "name": "stringlike?",
      "output": "bool"
    },
    "type?": {
      "description": "Returns true if the data type of a is the specified type 'sym, false  otherwise.",
      "input": "a 'sym",
      "name": "type?",
      "output": "bool"
    },
    "xor": {
      "description": "Returns true if bool1 and bool2 are different, false  otherwise.",
      "input": "bool1 bool2",
      "name": "xor",
      "output": "bool3"
    }
  },
  "math": {
    "abs": {
      "description": "Calculates tbe absolute value of num1.",
      "input": "num1",
      "name": "abs",
      "output": "num2"
    },
    "acos": {
      "description": "Calculates the arc cosine of num1 (in radians).",
      "input": "num1",
      "name": "acos",
      "output": "num2"
    },
    "asin": {
      "description": "Calculates the arc sine of num1 (in radians).",
      "input": "num1",
      "name": "asin",
      "output": "num2"
    },
    "atan": {
      "description": "Calculates the arc tangent of num1 (in radians).",
      "input": "num1",
      "name": "atan",
      "output": "num2"
    },
    "ceil": {
      "description": "Returns the smallest integer int that is not smaller than num.",
      "input": "num",
      "name": "ceil",
      "output": "int"
    },
    "cos": {
      "description": "Calculates the cosine of num1 (in radians).",
      "input": "num1",
      "name": "cos",
      "output": "num2"
    },
    "cosh": {
      "description": "Calculates the hyperbolic cosine of num1 (in radians).",
      "input": "num1",
      "name": "cosh",
      "output": "num2"
    },
    "d2r": {
      "description": "Converts num1 from degrees to radians.",
      "input": "num1",
      "name": "d2r",
      "output": "num2"
    },
    "e": {
      "description": "Returns the value of the _e_ constant (Euler's number).",
      "input": "",
      "name": "e",
      "output": "num"
    },
    "floor": {
      "description": "Returns the largest integer int that is not greater than num.",
      "input": "num",
      "name": "floor",
      "output": "int"
    },
    "ln": {
      "description": "Calculates the natural logarithm of num1.",
      "input": "num1",
      "name": "ln",
      "output": "num2"
    },
    "log10": {
      "description": "Calculates the common logarithm of num1.",
      "input": "num1",
      "name": "log10",
      "output": "num2"
    },
    "log2": {
      "description": "Calculates the binary logarithm of num1.",
      "input": "num1",
      "name": "log2",
      "output": "num2"
    },
    "pi": {
      "description": "Returns the value of the &pi; constant.",
      "input": "",
      "name": "pi",
      "output": "num"
    },
    "pow": {
      "description": "Computes num1 to power raised of num2.",
      "input": "num1 num2",
      "name": "pow",
      "output": "num3"
    },
    "r2d": {
      "description": "Converts num1 from radians to degrees.",
      "input": "num1",
      "name": "r2d",
      "output": "num2"
    },
    "round": {
      "description": "Rounds num1 to the int^th decimal place.",
      "input": "num1 int",
      "name": "round",
      "output": "num2"
    },
    "sin": {
      "description": "Calculates the sine of num1 (in radians).",
      "input": "num1",
      "name": "sin",
      "output": "num2"
    },
    "sinh": {
      "description": "Calculates the hyperbolic sine of num1 (in radians).",
      "input": "num1",
      "name": "sinh",
      "output": "num2"
    },
    "sqrt": {
      "description": "Returns square root of num1.",
      "input": "num1",
      "name": "sqrt",
      "output": "num2"
    },
    "tan": {
      "description": "Calculates the tangent of num1 (in radians).",
      "input": "num1",
      "name": "tan",
      "output": "num2"
    },
    "tanh": {
      "description": "Calculates the hyperbolic tangent of num1 (in radians).",
      "input": "num1",
      "name": "tanh",
      "output": "num2"
    },
    "tau": {
      "description": "Returns the value of the &tau; constant (2&pi;).",
      "input": "",
      "name": "tau",
      "output": "num"
    },
    "trunc": {
      "description": "Truncates num to the decimal point.",
      "input": "num1",
      "name": "trunc",
      "output": "num2"
    }
  },
  "net": {
    "accept": {
      "description": "Makes dict:socket2 (server) accept a connection from dict:socket1 (client). Returns the client socket dict:socket1 from which it will be possible to receive data from.",
      "input": "dict:socket1 dict:socket2",
      "name": "accept",
      "output": "dict:socket1"
    },
    "close": {
      "description": "Closes a previously-opened socket.",
      "input": "dict:socket",
      "name": "close",
      "output": ""
    },
    "connect": {
      "description": "Connects socket dict:socket to address string and port int.\n \n \n Example\n \n The following code shows how to send a message to a server running on localhost:7777. The message is passed as the first argument to the program.\n \n     {} socket \"localhost\" 7777 connect =cli\n     \n     args 1 get :msg\n     \n     \"Sending message \\\"$1\\\" to localhost:7777...\" (msg) =  send\n     \n     \"Done.\" puts!\n     \n     cli close",
      "input": "dict:socket string int",
      "name": "connect",
      "output": "dict:socket"
    },
    "recv": {
      "description": "Waits to receive int characters from dict:socket and returns the resulting data string.",
      "input": "dict:socket int",
      "name": "recv",
      "output": "string"
    },
    "recv-line": {
      "description": "Waits to receive a line of data from dict:socket and returns the resulting data string. \"\" is returned if dict:socket is disconnected.\n \n \n Example\n \n The following code shows how to make a simple GET request to <http://httpbin.org/uuid to receive a random UUID and display its response:\n \n \n     {} socket \"httpbin.org\" 80 connect =cli\n    \n     cli \"GET /uuid HTTP/1.1\\r\\nHost: httpbin.org\\r\\n\\r\\n\" send\n   \n     cli recv-line puts :line\n     (line \"\\}\" match not) \n     (\n       cli recv-line puts @line\n     ) while",
      "input": "dict:socket",
      "name": "recv-line",
      "output": "string"
    },
    "send": {
      "description": "Sends string to the connected socket dict:socket.",
      "input": "dict:socket string",
      "name": "send",
      "output": ""
    },
    "socket": {
      "description": "Opens a new socket.\n \n dict can be empty or contain any of the following properties, used to specify the domain, type and protocol of the socket respectively.\n \n domain\n : The socket domain. It can be set to one of the following values:\n   \n   *  **ipv4** (default): Internet Protocol version 4.\n   *  **ipv6**: Internet Protocol version 6.\n   *  **unix**: local Unix file (not supported on Windows systems).\n type\n : The socket type. It can be set to one of the following values:\n  \n   * **stream** (default): Reliable stream-oriented service or Stream Socket.\n   * **dgram**: Datagram service or Datagram Socket.\n   * **raw**: Raw protocols atop the network layer.\n   * **seqpacket**: Reliable sequenced packet service.\n protocol\n : The socket protocol. It can be set to one of the following values:\n \n   * **tcp** (default): Transmission Control Protocol.\n   * **udp**: User Datagram Protocol.\n   * **ipv4**: Internet Protocol version 4 (not supported on Windows systems).\n   * **ipv6**: Internet Protocol version 6 (not supported on Windows systems).\n   * **raw**: Raw IP Packets protocol (not supported on Windows systems).\n   * **icmp**: Internet Control Message Protocol (not supported on Windows systems).",
      "input": "dict",
      "name": "socket",
      "output": "dict:socket"
    }
  },
  "num": {
    "+": {
      "description": "Sums num1 and num2.",
      "input": "num1 num2",
      "name": "+",
      "output": "num3"
    },
    "-": {
      "description": "Subtracts num2 from num1.",
      "input": "num1 num2",
      "name": "-",
      "output": "num3"
    },
    "-inf": {
      "description": "Returns negative infinity.",
      "input": "",
      "name": "-inf",
      "output": "num"
    },
    "/": {
      "description": "Divides num1 by num2.",
      "input": "num1 num2",
      "name": "/",
      "output": "num3"
    },
    "\\*": {
      "description": "Multiplies num1 by num2.",
      "input": "num1 num2",
      "name": "\\*",
      "output": "num3"
    },
    "avg": {
      "description": "Returns the average of the items of quot.",
      "input": "quot",
      "name": "avg",
      "output": "num"
    },
    "bitand": {
      "description": "Computes the bitwise *and* of numbers int1 and int2.",
      "input": "int1 int2",
      "name": "bitand",
      "output": "int3"
    },
    "bitnot": {
      "description": "Computes the bitwise *complement* of int1.",
      "input": "int1",
      "name": "bitnot",
      "output": "int2"
    },
    "bitor": {
      "description": "Computes the bitwise *or* of numbers int1 and int2.",
      "input": "int1 int2",
      "name": "bitor",
      "output": "int3"
    },
    "bitxor": {
      "description": "Computes the bitwise *xor* of numbers int1 and int2.",
      "input": "int1 int2",
      "name": "bitxor",
      "output": "int3"
    },
    "div": {
      "description": "Divides int1 by int2 (integer division).",
      "input": "int1 int2",
      "name": "div",
      "output": "int3"
    },
    "even?": {
      "description": "Returns true if int is even, false  otherwise.",
      "input": "int",
      "name": "even?",
      "output": "bool"
    },
    "inf": {
      "description": "Returns infinity.",
      "input": "",
      "name": "inf",
      "output": "num"
    },
    "med": {
      "description": "Returns the median of the items of quot.",
      "input": "quot",
      "name": "med",
      "output": "num"
    },
    "mod": {
      "description": "Returns the integer module of int1 divided by int2.",
      "input": "int1 int2",
      "name": "mod",
      "output": "int3"
    },
    "nan": {
      "description": "Returns **NaN** (not a number).",
      "input": "",
      "name": "nan",
      "output": "nan"
    },
    "odd?": {
      "description": "Returns true if int is odd, false  otherwise.",
      "input": "int",
      "name": "odd?",
      "output": "bool"
    },
    "pred": {
      "description": "Returns the predecessor of int1.",
      "input": "int1",
      "name": "pred",
      "output": "int2"
    },
    "product": {
      "description": "Returns the product of all items of quot. quot is a quotation of integers.",
      "input": "quot",
      "name": "product",
      "output": "int"
    },
    "random": {
      "description": "Returns a random number int2 between 0 and int1-1. \n \n \n Note\n \n You must call randomize to initialize the random number generator, otherwise the same sequence of numbers will be returned.",
      "input": "int1",
      "name": "random",
      "output": "int2"
    },
    "randomize": {
      "description": "Initializes the random number generator using a seed based on the current timestamp.",
      "input": "",
      "name": "randomize",
      "output": "{{null}"
    },
    "range": {
      "description": "Takes a quotation quot1 of two or three integers in the form of *start*, *end* and an optional *step* (1 if not specified) and generates the sequence and returns the resulting quotation of integers quot2.",
      "input": "quot2",
      "name": "range",
      "output": "quot2"
    },
    "shl": {
      "description": "Computes the *shift left* operation of int1 and int2.",
      "input": "int1 int2",
      "name": "shl",
      "output": "int3"
    },
    "shr": {
      "description": "Computes the *shift right* operation of int1 and int2.",
      "input": "int1 int2",
      "name": "shr",
      "output": "int3"
    },
    "succ": {
      "description": "Returns the successor of int1.",
      "input": "int1",
      "name": "succ",
      "output": "int2"
    },
    "sum": {
      "description": "Returns the sum of all items of quot. quot is a quotation of integers.",
      "input": "quot",
      "name": "sum",
      "output": "int"
    }
  },
  "seq": {
    "all?": {
      "description": "Applies predicate quot2 to each element of quot1 and returns true if all elements of quot1 satisfy predicate quot2, false  otherwise.",
      "input": "quot1 quot2",
      "name": "all?",
      "output": "bool"
    },
    "any?": {
      "description": "Applies predicate quot2 to each element of quot1 and returns true if at least one element of quot1 satisfies predicate quot2, false  otherwise.",
      "input": "quot1 quot2",
      "name": "any?",
      "output": "bool"
    },
    "append": {
      "description": "Returns a new quotation containing the contents of quot with a appended.",
      "input": "a quot",
      "name": "append",
      "output": "(a* a)"
    },
    "concat": {
      "description": "Concatenates quot1 with quot2.",
      "input": "quot1 quot2",
      "name": "concat",
      "output": "quot3"
    },
    "difference": {
      "description": "Calculates the difference quot3 of quot1 and quot2.\n\n \n Example\n \n The following program leaves (2) on the stack:\n \n     (1 2 \"test\") (\"test\" \"a\" true 1) difference",
      "input": "quot1 quot2",
      "name": "difference",
      "output": "quot3"
    },
    "drop": {
      "description": "Returns a quotation quot2 containing the remaining elements after the first _n_ values of the input quotation quot1, or an empty quotation if int is greater than the length of quot1.",
      "input": "quot1 int",
      "name": "drop",
      "output": "quot2"
    },
    "filter": {
      "description": "Returns a new quotation quot3 containing all elements of quot1 that satisfy predicate quot2.\n \n \n Example\n \n The following program leaves (2 6 8 12) on the stack:\n \n     (1 37 34 2 6 8 12 21) \n     (dup 20 < swap even? and) filter",
      "input": "quot1 quot2",
      "name": "filter",
      "output": "quot3"
    },
    "find": {
      "description": "Returns the index of the first element within quot1 that satisfies predicate quot2, or -1 if no element satisfies it.\n \n \n Example\n \n The following program leaves 3 on the stack:\n \n     (1 2 4 8 16) \n     (5 ) find",
      "input": "quot1 quot2",
      "name": "find",
      "output": "int"
    },
    "first": {
      "description": "Returns the first element of quot.",
      "input": "quot",
      "name": "first",
      "output": "a"
    },
    "flatten": {
      "description": "Flattens all quotations within quot1 and returns the resulting sequence quot2.\n \n \n Example\n \n The following program leaves (1 2 3 4 5 6 7 8) on the stack:\n \n     (1 (2 3 4) 5 (6 7) 8) \n     flatten",
      "input": "quot1",
      "name": "flatten",
      "output": "quot2"
    },
    "get": {
      "description": "Returns the _n^th_ element of quot (zero-based).",
      "input": "quot int",
      "name": "get",
      "output": "a"
    },
    "harvest": {
      "description": "Creates a new quotation quot2 containing all elements of quot1 except for empty quotations.\n \n \n Example\n \n The following program leaves (1 2 3) on the stack:\n \n     (1 () () () 2 () 3) \n     harvest",
      "input": "quot1",
      "name": "harvest",
      "output": "quot2"
    },
    "in?": {
      "description": "Returns true if a is contained in quot, false  otherwise.",
      "input": "quot a",
      "name": "in?",
      "output": "bool"
    },
    "insert": {
      "description": "Inserts a as the value of the _n^th_ element quot1 (zero-based), and returns the modified copy of the quotation quot2.",
      "input": "quot1 a int",
      "name": "insert",
      "output": "quot2"
    },
    "intersection": {
      "description": "Calculates the intersection quot3 of quot1 and quot2.\n\n \n Example\n \n The following program leaves (1 \"test\") on the stack:\n \n     (1 2 \"test\") (\"test\" \"a\" true 1) intersection",
      "input": "quot1 quot2",
      "name": "intersection",
      "output": "quot3"
    },
    "last": {
      "description": "Returns the last element of quot.",
      "input": "quot",
      "name": "last",
      "output": "a"
    },
    "map": {
      "description": "Returns a new quotation quot3 obtained by applying quot2 to each element of quot1.",
      "input": "quot1 quot2",
      "name": "map",
      "output": "quot3"
    },
    "map-reduce": {
      "description": "Applies quot2 (map) to each element of quot1 and then applies quot3 (reduce) to each successive element of quot1. quot1 must have at least one element.\n \n \n Example\n \n The following program leaves 35 on the stack:\n \n     (1 3 5) \n     (dup *) (+) map-reduce",
      "input": "quot1 quot2 quot3",
      "name": "map-reduce",
      "output": "int"
    },
    "one?": {
      "description": "Applies predicate quot2 to each element of quot1 and returns true if only one element of quot1 satisfies predicate quot2, false  otherwise.",
      "input": "quot1 quot2",
      "name": "one?",
      "output": "bool"
    },
    "partition": {
      "description": "Partitions quot1 into two quotations: quot3 contains all elements of quot1 that satisfy predicate quot2, quot4 all the others.\n \n \n Example\n \n The following program leaves (1 3 5) (2 4 6) on the stack:\n \n     (1 2 3 4 5 6) \n     (odd?) partition",
      "input": "quot1 quot2",
      "name": "partition",
      "output": "quot3 quot4"
    },
    "prepend": {
      "description": "Returns a new quotation containing the contents of quot with a prepended.",
      "input": "a quot",
      "name": "prepend",
      "output": "(a a*)"
    },
    "quote-map": {
      "description": "Returns a new quotation quot2 obtained by quoting each element of quot1.",
      "input": "quot1",
      "name": "quote-map",
      "output": "quot2"
    },
    "reduce": {
      "description": "Combines each successive element of quot1 using quot2. On the first iteration, the first two inputs processed by quot2 are a and the first element of quot1.\n \n \n Example\n \n The following program leaves 120 on the stack:\n \n     (1 2 3 4 5) \n     1 (*) reduce",
      "input": "quot1 a quot2",
      "name": "reduce",
      "output": "int"
    },
    "reject": {
      "description": "Returns a new quotatios quot3 including all elements of quot1 that do not satisfy predicate quot2 (i.e. the opposite of filter)",
      "input": "quot1 quot2",
      "name": "reject",
      "output": "quot3"
    },
    "remove": {
      "description": "Returns the _n^th_ element of quot1 (zero-based), and returns the modified copy of the quotation quot2.",
      "input": "quot1 int",
      "name": "remove",
      "output": "quot2"
    },
    "rest": {
      "description": "Returns a new quotation quot2 containing all elements of quot1 quotation except for the first.",
      "input": "quot1",
      "name": "rest",
      "output": "quot2"
    },
    "reverse": {
      "description": "Returns a new quotation quot2 containing all elements of quot1 in reverse order.",
      "input": "quot1",
      "name": "reverse",
      "output": "quot2"
    },
    "set": {
      "description": "Sets the value of the _n^th_ element quot1 (zero-based) to a, and returns the modified copy of the quotation quot2.",
      "input": "quot1 a int",
      "name": "set",
      "output": "quot2"
    },
    "shorten": {
      "description": "Returns a quotation quot2 containing the first _n_ values of the input quotation quot1.",
      "input": "quot1 int",
      "name": "shorten",
      "output": "quot2"
    },
    "size": {
      "description": "Returns the length of quot.",
      "input": "quot",
      "name": "size",
      "output": "int"
    },
    "slice": {
      "description": "Creates a new quotation quot2 obtaining by selecting all elements of quot1 between indexes int1 and int2.\n \n \n Example\n \n The following program leaves (3 4 5) on the stack:\n \n     (1 2 3 4 5 6) \n     2 4 slice",
      "input": "quot1 int1 int2",
      "name": "slice",
      "output": "quot2"
    },
    "sort": {
      "description": "Sorts all elements of quot1 according to predicate quot2. \n \n \n Example\n \n The following program leaves (1 3 5 7 9 13 16) on the stack:\n \n     (1 9 5 13 16 3 7) ' sort",
      "input": "quot1 quot2",
      "name": "sort",
      "output": "quot3"
    },
    "symmetric-difference": {
      "description": "Calculates the symmetric difference quot3 of quot1 and quot2.\n\n \n Example\n \n The following program leaves (true \"a\" 2) on the stack:\n \n     (1 2 \"test\") (\"test\" \"a\" true 1) symmetric-difference",
      "input": "quot1 quot2",
      "name": "symmetric-difference",
      "output": "quot3"
    },
    "take": {
      "description": "Returns a quotation quot2 containing the first _n_ values of the input quotation quot1, or quot1 itself if int is greater than the length of quot1.",
      "input": "quot1 int",
      "name": "take",
      "output": "quot2"
    },
    "union": {
      "description": "Calculates the union quot3 of quot1 and quot2.\n\n \n Example\n \n The following program leaves (true 1 \"test\" \"a\" 2) on the stack:\n \n     (1 2 \"test\") (\"test\" \"a\" true 1) union",
      "input": "quot1 quot2",
      "name": "union",
      "output": "quot3"
    }
  },
  "stack": {
    "clear-stack": {
      "description": "Empties the stack.",
      "input": "a",
      "name": "clear-stack",
      "output": ""
    },
    "cleave": {
      "description": "Applies each quotation contained in the first element to the second element a1.\n \n Example\n \n The following program leaves 2 on the stack:\n \n (1 2 3) ((sum) (size)) cleave /",
      "input": "a1 (quot*)",
      "name": "cleave",
      "output": "a*"
    },
    "cons": {
      "description": "Prepends a1 to the quotation on top of the stack.",
      "input": "a1 (a*)",
      "name": "cons",
      "output": "(a1 a*)"
    },
    "dip": {
      "description": "Removes the first and second element from the stack, dequotes the first element, and restores the second element.",
      "input": "a1 (a2)",
      "name": "dip",
      "output": "a* a1"
    },
    "dup": {
      "description": "Duplicates the first element on the stack.",
      "input": "a1",
      "name": "dup",
      "output": "a1 a1"
    },
    "get-stack": {
      "description": "Puts a quotation containing the contents of the stack on the stack.",
      "input": "",
      "name": "get-stack",
      "output": "(a*)"
    },
    "id": {
      "description": "Does nothing.",
      "input": "",
      "name": "id",
      "output": ""
    },
    "keep": {
      "description": "Applies each quotation contained in the first element to each subsequent corresponding element.\n \n Example\n \n The following program leaves 5 3 on the stack:\n \n 2 3 '+ keep",
      "input": "a1 quot",
      "name": "keep",
      "output": "a* a1"
    },
    "nip": {
      "description": "Removes the second element from the stack.",
      "input": "a1 a2",
      "name": "nip",
      "output": "a2"
    },
    "over": {
      "description": "Pushes a copy of the second element on top of the stack.",
      "input": "a1 a2",
      "name": "over",
      "output": "a1 a2 a1"
    },
    "pick": {
      "description": "Pushes a copy of the third element on top of the stack.",
      "input": "a1 a2 a3",
      "name": "pick",
      "output": "a1 a2 a3 a1"
    },
    "pop": {
      "description": "Removes the first element from the stack.",
      "input": "a",
      "name": "pop",
      "output": ""
    },
    "rolldown": {
      "description": "Moves the third element in first position, the second in third position and the the first in second position.",
      "input": "a1 a2 a3",
      "name": "rolldown",
      "output": "a2 a3 a1"
    },
    "rollup": {
      "description": "Moves the third and second element into second and third position and moves the first element into third position.",
      "input": "a1 a2 a3",
      "name": "rollup",
      "output": "a3 a2 a1"
    },
    "set-stack": {
      "description": "Substitute the existing stack with the contents of quot.",
      "input": "quot",
      "name": "set-stack",
      "output": "a*"
    },
    "sip": {
      "description": "Saves the a1, dequotes a2, and restores a1.",
      "input": "a1 (a2)",
      "name": "sip",
      "output": "a* a1"
    },
    "spread": {
      "description": "Applies each quotation contained in the first element to each subsequent corresponding element.\n \n Example\n \n The following program leaves (1 4) on the stack:\n \n (1 2) (3 4) ((0 get) (1 get)) spread",
      "input": "a* (quot*)",
      "name": "spread",
      "output": "a*"
    },
    "swap": {
      "description": "Swaps the first two elements on the stack.",
      "input": "a1 a2",
      "name": "swap",
      "output": "a2 a1"
    },
    "swons": {
      "description": "Prepends a1 to the quotation that follows it.",
      "input": "(a*) a1",
      "name": "swons",
      "output": "(a1 a*)"
    }
  },
  "str": {
    "apply-interpolate": {
      "description": "The same as pushing apply and then interpolate on the stack.",
      "input": "string quot",
      "name": "apply-interpolate",
      "output": "string"
    },
    "capitalize": {
      "description": "Returns a copy of 'sym with the first character capitalized.",
      "input": "'sym",
      "name": "capitalize",
      "output": "string"
    },
    "chr": {
      "description": "Returns the single character string obtained by interpreting int as an ASCII code.",
      "input": "int",
      "name": "chr",
      "output": "string"
    },
    "escape": {
      "description": "Returns a copy of 'sym with quotes and backslashes escaped with a backslash.",
      "input": "'sym",
      "name": "escape",
      "output": "string"
    },
    "from-semver": {
      "description": "Given a basic [SemVer](https://semver.org)-compliant string (with no additional labels) string, \nit pushes a dictionary dict on the stack containing a **major**, **minor**, and **patch** key/value pairs.",
      "input": "string",
      "name": "from-semver",
      "output": "dict"
    },
    "indent": {
      "description": "Returns string containing 'sym indented with int spaces.",
      "input": "'sym int",
      "name": "indent",
      "output": "string"
    },
    "indexof": {
      "description": "If string2 is contained in string1, returns the index of the first match or -1 if no match is found.",
      "input": "string1 string2",
      "name": "indexof",
      "output": "int"
    },
    "join": {
      "description": "Joins the elements of quot using separator 'sym, producing string.",
      "input": "quot 'sym",
      "name": "join",
      "output": "string"
    },
    "length": {
      "description": "Returns the length of 'sym.",
      "input": "'sym",
      "name": "length",
      "output": "int"
    },
    "lowercase": {
      "description": "Returns a copy of 'sym converted to lowercase.",
      "input": "'sym",
      "name": "lowercase",
      "output": "string"
    },
    "match": {
      "description": "Returns true if string2 matches string1, false  otherwise.\n \n Tip\n \n string2 can be a sgregex-compatible regular expression.",
      "input": "string1 string2",
      "name": "match",
      "output": "bool"
    },
    "ord": {
      "description": "Returns the ASCII code int corresponding to the single character string.",
      "input": "string",
      "name": "ord",
      "output": "int"
    },
    "parse-url": {
      "description": "Parses the url string into its components and stores them into url.",
      "input": "string",
      "name": "parse-url",
      "output": "url"
    },
    "prefix": {
      "description": "Prepends 'sym2 to 'sym1.",
      "input": "'sym1 'sym2",
      "name": "prefix",
      "output": "string"
    },
    "regex": {
      "description": "Performs a search and/or a search-and-replace operation using pattern string2.\n \n string2 can be one of the following patterns:\n \n   * **/**_search-regex_**/**_modifiers_\n   * **s/**_search-regex_**/**_replacemenet_**/**_modifiers_\n \n quot is always a quotation containing:\n \n   * One or more strings containing the first match and captures (if any), like for the search operator.\n   * A string containing the resuling string after the search-and-replace operation.\n \n \n Tip\n \n * _search-regex_ can be a sgregex-compatible regular expression.\n * _modifiers_ are optionals can contain one or more of the following characters, in any order:\n   * **i**: case-insensitive match.\n   * **m**: multi-line match.\n   * **s**: dot character includes newlines.\n \n \n Example: Search\n \n The following:\n \n \"This is a GOOD idea.\" \"/(good) idea/i\" regex\n \n produces: (\"GOOD idea\", \"GOOD\")\n \n \n Example: Search and Replace\n \n The following:\n \n \"This is a GOOD idea.\" \"s/good/bad/i\" regex\n \n produces: (\"This is a bad idea\")",
      "input": "string1 string2",
      "name": "regex",
      "output": "quot"
    },
    "repeat": {
      "description": "Returns string containing 'sym repeated int times.",
      "input": "'sym int",
      "name": "repeat",
      "output": "string"
    },
    "replace": {
      "description": "Returns a copy of string1 containing all occurrences of string2 replaced by string3\n \n Tip\n \n string2 can be a sgregex-compatible regular expression.\n \n \n Example\n \n The following:\n \n \"This is a stupid test. Is it really a stupid test?\" \" s[a-z]+\" \" simple\" replace\n \n produces:\n \n \"This is a simple test. Is it really a simple test?\"",
      "input": "string1 string2 string3",
      "name": "replace",
      "output": "string4"
    },
    "search": {
      "description": "Returns a quotation of quotations (like the one returned by the search operator) containing all occurrences of string2 within string1.",
      "input": "string1 string2",
      "name": "search",
      "output": "quot"
    },
    "semver-inc-major": {
      "description": "Increments the major digit of the [SemVer](https://semver.org)-compliant string (with no additional labels) string1.",
      "input": "string1",
      "name": "semver-inc-major",
      "output": "string2"
    },
    "semver-inc-minor": {
      "description": "Increments the minor digit of the [SemVer](https://semver.org)-compliant string (with no additional labels) string1.",
      "input": "string1",
      "name": "semver-inc-minor",
      "output": "string2"
    },
    "semver-inc-patch": {
      "description": "Increments the patch digit of the [SemVer](https://semver.org)-compliant string (with no additional labels) string1.",
      "input": "string1",
      "name": "semver-inc-patch",
      "output": "string2"
    },
    "semver?": {
      "description": "Checks whether string is a [SemVer](https://semver.org)-compliant version or not.",
      "input": "string",
      "name": "semver?",
      "output": "bool"
    },
    "split": {
      "description": "Splits 'sym1 using separator 'sym2 and returns the resulting strings within the quotation quot.",
      "input": "'sym1 'sym2",
      "name": "split",
      "output": "quot"
    },
    "strip": {
      "description": "Returns string, which is set to 'sym with leading and trailing spaces removed.",
      "input": "'sym",
      "name": "strip",
      "output": "string"
    },
    "substr": {
      "description": "Returns a substring string2 obtained by retriving int2 characters starting from index int1 within string1.",
      "input": "string1 int1 int2",
      "name": "substr",
      "output": "string2"
    },
    "suffix": {
      "description": "Appends 'sym2 to 'sym1.",
      "input": "'sym1 'sym2",
      "name": "suffix",
      "output": "string"
    },
    "titleize": {
      "description": "Returns a copy of 'sym in which the first character of each word is capitalized.",
      "input": "'sym",
      "name": "titleize",
      "output": "string"
    },
    "to-semver": {
      "description": "Given a a dictionary dict containing a **major**, **minor**, and **patch** key/value pairs , it pushes a basic [SemVer](https://semver.org)-compliant string (with no additional labels) string on the stack.",
      "input": "dict",
      "name": "to-semver",
      "output": "string"
    },
    "uppercase": {
      "description": "Returns a copy of 'sym converted to uppercase.",
      "input": "'sym1",
      "name": "uppercase",
      "output": "'sym2"
    }
  },
  "sys": {
    ".": {
      "description": "Returns the full path to the current directory.",
      "input": "",
      "name": ".",
      "output": "string"
    },
    "..": {
      "description": "Returns the full path to the parent directory.",
      "input": "",
      "name": "..",
      "output": "string"
    },
    "cd": {
      "description": "Change the current directory to 'sym.",
      "input": "'sym",
      "name": "cd",
      "output": ""
    },
    "chmod": {
      "description": "Sets the permissions of file or directory 'sym to int. int is a three-digit representation of user, group and other permissions. See the [Unix Permissions Calculator](http://permissions-calculator.org/) for examples and conversions.\n \n \n Example\n \n The following program makes the file **/tmp/test.txt** readable, writable and executable by its owner, and readable and executable by users of the same group and all other users:\n \n /tmp/test.txt 755 chmod",
      "input": "'sym int",
      "name": "chmod",
      "output": ""
    },
    "cp": {
      "description": "Copies the file or directory 'sym1 to 'sym2.",
      "input": "'sym1 'sym2",
      "name": "cp",
      "output": ""
    },
    "cpu": {
      "description": "Returns the host CPU. It can be one of the following strings i386, alpha, powerpc, powerpc64, powerpc64el, sparc, amd64, mips, mipsel, arm, arm64.",
      "input": "",
      "name": "cpu",
      "output": "string"
    },
    "dir?": {
      "description": "Returns true if the specified path 'sym exists and is a directory.",
      "input": "'sym",
      "name": "dir?",
      "output": "bool"
    },
    "dirname": {
      "description": "Returns the path of the directory containing path 'sym.",
      "input": "'sym",
      "name": "dirname",
      "output": "string"
    },
    "env?": {
      "description": "Returns true if environment variable 'sym exists, false  otherwise.",
      "input": "'sym",
      "name": "env?",
      "output": "bool"
    },
    "exists?": {
      "description": "Returns true if the specified file or directory 'sym exists.",
      "input": "'sym",
      "name": "exists?",
      "output": "bool"
    },
    "file?": {
      "description": "Returns true if the specified path 'sym exists and is a file.",
      "input": "'sym",
      "name": "file?",
      "output": "bool"
    },
    "filename": {
      "description": "Returns the file name of path 'sym.",
      "input": "'sym",
      "name": "filename",
      "output": "string"
    },
    "get-env": {
      "description": "Returns environment variable 'sym.",
      "input": "'sym",
      "name": "get-env",
      "output": "string"
    },
    "hardlink": {
      "description": "Creates hardlink 'sym2 for file or directory 'sym1.",
      "input": "'sym1 'sym2",
      "name": "hardlink",
      "output": ""
    },
    "ls": {
      "description": "Returns a quotation quot containing all children (files and directories) of the directory 'sym.",
      "input": "'sym",
      "name": "ls",
      "output": "quot"
    },
    "ls-r": {
      "description": "Returns a quotation quot containing all children (files and directories) of the directory 'sym, recursively.",
      "input": "'sym",
      "name": "ls-r",
      "output": "quot"
    },
    "mkdir": {
      "description": "Creates the specified directory 'sym.",
      "input": "'sym",
      "name": "mkdir",
      "output": ""
    },
    "mv": {
      "description": "Moves the file or directory 'sym1 to 'sym2.",
      "input": "'sym1 'sym2",
      "name": "mv",
      "output": ""
    },
    "os": {
      "description": "Returns the host operating system. It can be one of the following strings: windows, macosx, linux, netbsd, freebsd, openbsd, solaris, aix, standalone.",
      "input": "",
      "name": "os",
      "output": "string"
    },
    "put-env": {
      "description": "Sets environment variable 'sym2 to 'sym1.",
      "input": "'sym1 'sym2",
      "name": "put-env",
      "output": "string"
    },
    "rm": {
      "description": "Deletes the specified file 'sym.",
      "input": "'sym",
      "name": "rm",
      "output": ""
    },
    "rmdir": {
      "description": "Deletes the specified directory 'sym and all its subdirectories recursively.",
      "input": "'sym",
      "name": "rmdir",
      "output": ""
    },
    "run": {
      "description": "Executes the external command 'sym in the current directory without displaying its output. Returns a dictionary containing the command output and return code (in keys **output** and **code** respectively).",
      "input": "'sym",
      "name": "run",
      "output": "dict"
    },
    "sleep": {
      "description": "Halts program execution for int milliseconds.",
      "input": "int",
      "name": "sleep",
      "output": ""
    },
    "symlink": {
      "description": "Creates symlink 'sym2 for file or directory 'sym1.",
      "input": "'sym1 'sym2",
      "name": "symlink",
      "output": ""
    },
    "symlink?": {
      "description": "Returns true if the specified path 'sym exists and is a symbolic link.",
      "input": "'sym",
      "name": "symlink?",
      "output": "bool"
    },
    "system": {
      "description": "Executes the external command 'sym in the current directory and pushes its return code on the stack.",
      "input": "'sym",
      "name": "system",
      "output": "int"
    },
    "system!": {
      "description": "Executes the external command 'sym in the current directory without pushing its return code on the stack.",
      "input": "'sym",
      "name": "system!",
      "output": ""
    },
    "unzip": {
      "description": "Decompresses zip file 'sym1 to directory 'sym2 (created if not present).",
      "input": "'sym1 'sym2",
      "name": "unzip",
      "output": ""
    },
    "which": {
      "description": "Returns the full path to the directory containing executable 'sym, or an empty string if the executable is not found in **$PATH**.",
      "input": "'sym",
      "name": "which",
      "output": "string"
    },
    "zip": {
      "description": "Compresses files included in quotation quot into zip file 'sym.",
      "input": "'sym quot",
      "name": "zip",
      "output": ""
    }
  },
  "time": {
    "datetime": {
      "description": "Returns an ISO 8601 string representing the combined date and time in UTC of timestamp int.",
      "input": "int",
      "name": "datetime",
      "output": "string"
    },
    "now": {
      "description": "Returns the current time as Unix timestamp with microseconds.",
      "input": "",
      "name": "now",
      "output": "float"
    },
    "timeinfo": {
      "description": "Returns a timeinfo dictionary from timestamp int.",
      "input": "int",
      "name": "timeinfo",
      "output": "dict:timeinfo"
    },
    "timestamp": {
      "description": "Returns the current time as Unix timestamp.",
      "input": "",
      "name": "timestamp",
      "output": "int"
    },
    "to-timestamp": {
      "description": "Converts the timeinfo dictionary dict:timeinfo to the corresponding Unix timestamp.",
      "input": "dict:timeinfo",
      "name": "to-timestamp",
      "output": "int"
    }
  }
}